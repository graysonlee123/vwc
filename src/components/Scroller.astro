---
import { Image } from 'astro:assets';

import type { ComponentProps } from 'astro/types';

interface Props {
  propsForImages: ComponentProps<typeof Image>[];
  scrollDirection?: 'forwards' | 'backwards';
  staggerSizes?: boolean;
  flushAgainst?: 'left' | 'right';
}

const {
  propsForImages,
  scrollDirection = 'forwards',
  staggerSizes = false,
  flushAgainst,
} = Astro.props;
---

<div
  class:list={{
    track: true,
    'scroll-direction--forwards': scrollDirection !== 'backwards',
    'scroll-direction--backwards': scrollDirection === 'backwards',
    'stagger-sizes': staggerSizes === true,
    'flush-against--left': flushAgainst === 'left',
    'flush-against--right': flushAgainst === 'right',
  }}
>
  <div class="train">
    {
      propsForImages.map((imageProps, i) => (
        <Image
          class="image"
          sizes={staggerSizes ? (i % 2 ? '312px' : '416px') : '306px'}
          {...imageProps}
        />
      ))
    }
  </div>
</div>

<style>
  .track {
    position: relative;
    z-index: 0;
    height: 100%;
    overflow: hidden;
  }

  .train {
    position: absolute;
    top: 0;
    display: grid;
    justify-items: end;
    gap: var(--gap);
    animation-name: slide-up;
    animation-play-state: paused;
    animation-duration: 40s;
    animation-iteration-count: infinite;
    animation-timing-function: linear;
  }

  .track[data-scroller-animate='true'] .train {
    animation-play-state: running;
  }

  .scroll-direction--backwards .train {
    animation-duration: 50s;
  }

  .image {
    width: 100%;
    height: auto;
    border-radius: 2rem;
    border-width: 2px;
    border-style: solid;
    border-color: hsl(var(--color--gray--100));
  }

  @media (width < 62rem) {
    .track {
      --height: 12rem;

      height: var(--height);
    }

    .train {
      grid-auto-flow: column;
      grid-auto-columns: 20rem;
      animation-name: slide-right;
    }

    .image {
      height: var(--height);
      object-fit: cover;
    }

    .scroll-direction--backwards .train {
      animation-name: slide-left;
    }
  }

  @media (width >= 62rem) {
    .scroll-direction--backwards .train {
      animation-name: slide-down;
    }

    .stagger-sizes .image:nth-child(even) {
      width: 75%;
    }

    .flush-against--left .image {
      border-top-left-radius: 0;
      border-bottom-left-radius: 0;
      border-left-width: 0;
    }

    .flush-against--right .image {
      border-top-right-radius: 0;
      border-bottom-right-radius: 0;
      border-right-width: 0;
    }
  }

  @keyframes slide-right {
    to {
      transform: translateX(calc(-50% - var(--gap) / 2));
    }
  }

  @keyframes slide-left {
    from {
      transform: translateX(calc(-50% - var(--gap) / 2));
    }

    to {
      transform: translateX(calc(0%));
    }
  }

  @keyframes slide-up {
    to {
      transform: translateY(calc(-50% - var(--gap) / 2));
    }
  }

  @keyframes slide-down {
    from {
      transform: translateY(calc(-50% - var(--gap) / 2));
    }

    to {
      transform: translateY(calc(0%));
    }
  }
</style>

<script>
  if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
    document.querySelectorAll('.track').forEach(initScroller);
  }

  /**
   * Initializes scrollers.
   *
   * TODO: Setup an observation observer.
   *
   * @param scroller Scroller element.
   */
  function initScroller(scroller: Element) {
    scroller.setAttribute('data-scroller-animate', 'true');

    const isReverse =
      scroller.getAttribute('data-scroller-direction') === 'reverse';
    const scrollerInner = scroller.querySelector('.train');

    if (!scrollerInner) {
      console.warn('Could not find train for scroller track.', scroller);
      return;
    }

    const scrollerContent = Array.from(scrollerInner.children);

    if (isReverse) {
      scrollerContent.reverse();
    }

    scrollerContent.forEach((item) => {
      const duplicatedItem = item.cloneNode(true);

      if (duplicatedItem instanceof Element) {
        duplicatedItem.setAttribute('aria-hidden', 'true');

        if (isReverse) {
          scrollerInner.prepend(duplicatedItem);
        } else {
          scrollerInner.appendChild(duplicatedItem);
        }
      }
    });
  }
</script>
